// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "RenderGraphBuilder.h"
#include "RenderGraphResources.h"
#include "GlobalShader.h"
#include "RHI.h"
#include "RHIResources.h"
#include "RenderResource.h"
#include "GPUTessellationComponent.h"

class UTexture2D;

/**
 * Mesh data generated by compute shaders (CPU copy)
 */
struct FGPUTessellatedMeshData
{
	TArray<FVector3f> Vertices;
	TArray<FVector3f> Normals;
	TArray<FVector2f> UVs;
	TArray<uint32> Indices;

	int32 ResolutionX = 0;
	int32 ResolutionY = 0;

	void Reset()
	{
		Vertices.Empty();
		Normals.Empty();
		UVs.Empty();
		Indices.Empty();
		ResolutionX = 0;
		ResolutionY = 0;
	}

	bool IsValid() const
	{
		return Vertices.Num() > 0 && Indices.Num() > 0;
	}
};

/**
 * GPU-only mesh buffers (no CPU copy) for pure GPU rendering
 * Used by scene proxy to render directly from GPU buffers
 */
struct FGPUTessellationBuffers : public FRenderResource
{
	// Persistent GPU buffers
	FBufferRHIRef PositionBuffer;
	FBufferRHIRef NormalBuffer;
	FBufferRHIRef UVBuffer;
	FBufferRHIRef TangentBuffer;  // float4: xyz = tangent, w = binormal sign
	FBufferRHIRef IndexBufferRHI;
	
	// Shader resource views
	FShaderResourceViewRHIRef PositionSRV;
	FShaderResourceViewRHIRef NormalSRV;
	FShaderResourceViewRHIRef UVSRV;
	FShaderResourceViewRHIRef TangentSRV;
	
	// Index buffer wrapper for mesh batch
	class FGPUIndexBuffer : public FIndexBuffer
	{
	public:
		// Note: IndexBufferRHI is inherited from FIndexBuffer base class
		
		virtual void InitRHI(FRHICommandListBase& RHICmdList) override 
		{
			// Already initialized externally, nothing to do
		}
		
		virtual void ReleaseRHI() override 
		{ 
			IndexBufferRHI.SafeRelease(); 
		}
	};
	
	FGPUIndexBuffer IndexBuffer;
	
	// Metadata
	int32 VertexCount = 0;
	int32 IndexCount = 0;
	int32 ResolutionX = 0;
	int32 ResolutionY = 0;
	
	bool IsValid() const
	{
		return PositionBuffer.IsValid() && 
		       NormalBuffer.IsValid() && 
		       UVBuffer.IsValid() && 
		       IndexBufferRHI.IsValid() &&
		       VertexCount > 0 && 
		       IndexCount > 0;
		// Note: TangentBuffer is optional - not required for basic rendering
	}
	
	void Reset()
	{
		// Release the index buffer render resource if it was initialized
		if (IndexBuffer.IsInitialized())
		{
			IndexBuffer.ReleaseResource();
		}
		
		PositionBuffer.SafeRelease();
		NormalBuffer.SafeRelease();
		UVBuffer.SafeRelease();
		TangentBuffer.SafeRelease();
		IndexBufferRHI.SafeRelease();
		PositionSRV.SafeRelease();
		NormalSRV.SafeRelease();
		UVSRV.SafeRelease();
		TangentSRV.SafeRelease();
		VertexCount = 0;
		IndexCount = 0;
		ResolutionX = 0;
		ResolutionY = 0;
	}
	
	virtual void InitRHI(FRHICommandListBase& RHICmdList) override {}
	virtual void ReleaseRHI() override { Reset(); }
};

/**
 * Single patch information for spatial patch system
 */
struct FGPUTessellationPatchInfo
{
	FVector2f PatchOffset;         // Offset in UV space [0,1] - where patch starts
	FVector2f PatchSize;           // Size in UV space [0,1]
	FVector WorldCenter;           // World space center for LOD/culling
	FBox WorldBounds;              // World space bounds for frustum culling
	int32 TessellationLevel;       // Tessellation factor (4,8,16,32,64,128)
	int32 PatchIndexX;             // Patch grid X index
	int32 PatchIndexY;             // Patch grid Y index
	bool bVisible;                 // Frustum culling result
	
	FGPUTessellationPatchInfo()
		: PatchOffset(0, 0)
		, PatchSize(1, 1)
		, WorldCenter(FVector::ZeroVector)
		, WorldBounds(ForceInit)
		, TessellationLevel(16)
		, PatchIndexX(0)
		, PatchIndexY(0)
		, bVisible(true)
	{}
};

/**
 * Collection of patch buffers for spatial patch rendering
 */
struct FGPUTessellationPatchBuffers : public FRenderResource
{
	// Array of buffers, one per patch
	TArray<FGPUTessellationBuffers> PatchBuffers;
	
	// Patch metadata
	TArray<FGPUTessellationPatchInfo> PatchInfo;
	
	// Patch grid dimensions
	int32 PatchCountX = 1;
	int32 PatchCountY = 1;
	
	int32 GetTotalPatchCount() const { return PatchCountX * PatchCountY; }
	
	bool IsValid() const
	{
		return PatchBuffers.Num() > 0 && PatchBuffers.Num() == GetTotalPatchCount();
	}
	
	void Reset()
	{
		for (FGPUTessellationBuffers& Patch : PatchBuffers)
		{
			Patch.Reset();
		}
		PatchBuffers.Empty();
		PatchInfo.Empty();
		PatchCountX = 1;
		PatchCountY = 1;
	}
	
	virtual void InitRHI(FRHICommandListBase& RHICmdList) override {}
	virtual void ReleaseRHI() override { Reset(); }
};

/**
 * GPU Tessellation Mesh Builder
 * 
 * Executes the compute shader pipeline to generate tessellated mesh data.
 * Uses RDG (Render Dependency Graph) for proper resource management.
 */
class GPURUNTIMETESSELLATION_API FGPUTessellationMeshBuilder
{
public:
	FGPUTessellationMeshBuilder();
	~FGPUTessellationMeshBuilder();

	/**
	 * Execute the full tessellation pipeline on the GPU (CPU readback version)
	 * 
	 * @param GraphBuilder - RDG builder for compute pass management
	 * @param Settings - Tessellation settings
	 * @param LocalToWorld - Transform matrix
	 * @param CameraPosition - Camera position for LOD
	 * @param DisplacementTexture - Optional displacement texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param RVTMaskTexture - Optional RVT mask texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param NormalMapTexture - Optional normal map texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param OutMeshData - Generated mesh data (filled after GPU execution completes)
	 */
	void ExecuteTessellationPipeline(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		const FMatrix& LocalToWorld,
		const FVector& CameraPosition,
		UTexture* DisplacementTexture,
		UTexture* RVTMaskTexture,
		UTexture* NormalMapTexture,
		FGPUTessellatedMeshData& OutMeshData);

	/**
	 * Execute the full tessellation pipeline on the GPU (Pure GPU version - no CPU readback)
	 * Creates persistent GPU buffers that stay on GPU for rendering
	 * 
	 * @param GraphBuilder - RDG builder for compute pass management
	 * @param Settings - Tessellation settings
	 * @param LocalToWorld - Transform matrix
	 * @param CameraPosition - Camera position for LOD
	 * @param DisplacementTexture - Optional displacement texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param SubtractTexture - Optional subtract/mask texture (supports UTexture2D and UTextureRenderTarget2D for realtime painting)
	 * @param NormalMapTexture - Optional normal map texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param OutGPUBuffers - GPU buffer references (no CPU copy)
	 */
	void ExecuteTessellationPipeline(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		const FMatrix& LocalToWorld,
		const FVector& CameraPosition,
		UTexture* DisplacementTexture,
		UTexture* SubtractTexture,
		UTexture* NormalMapTexture,
		FGPUTessellationBuffers& OutGPUBuffers);

	/**
	 * Execute spatial patch tessellation pipeline (Pure GPU, multiple patches)
	 * Generates multiple independent patches with per-patch LOD
	 * 
	 * @param GraphBuilder - RDG builder for compute pass management
	 * @param Settings - Tessellation settings
	 * @param LocalToWorld - Transform matrix
	 * @param CameraPosition - Camera position for per-patch LOD
	 * @param ViewFrustum - View frustum for per-patch culling
	 * @param PatchCountX - Number of patches in X direction
	 * @param PatchCountY - Number of patches in Y direction
	 * @param DisplacementTexture - Optional displacement texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param SubtractTexture - Optional subtract/mask texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param NormalMapTexture - Optional normal map texture (supports UTexture2D and UTextureRenderTarget2D)
	 * @param OutPatchBuffers - GPU buffer references for all patches (no CPU copy)
	 */
	void ExecutePatchTessellationPipeline(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		const FMatrix& LocalToWorld,
		const FVector& CameraPosition,
		const FConvexVolume* ViewFrustum,
		int32 PatchCountX,
		int32 PatchCountY,
		UTexture* DisplacementTexture,
		UTexture* SubtractTexture,
		UTexture* NormalMapTexture,
		FGPUTessellationPatchBuffers& OutPatchBuffers);

	/**
	 * Synchronous mesh generation (simpler version for testing)
	 * Generates mesh data on GPU and immediately reads back to CPU
	 */
	void GenerateMeshSync(
		const FGPUTessellationSettings& Settings,
		const FMatrix& LocalToWorld,
		const FVector& CameraPosition,
		UTexture* DisplacementTexture,
		UTexture* RVTMaskTexture,
		FGPUTessellatedMeshData& OutMeshData);

private:
	/**
	 * Calculate grid resolution from tessellation factor
	 */
	FIntPoint CalculateResolution(float TessellationFactor) const;

	/**
	 * Dispatch vertex generation compute shader
	 */
	void DispatchVertexGeneration(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		FIntPoint Resolution,
		const FMatrix& LocalToWorld,
		const FVector& PatchLocalOffset,
		FRDGBufferRef& OutVertexBuffer,
		FRDGBufferRef& OutNormalBuffer,
		FRDGBufferRef& OutUVBuffer);

	/**
	 * Dispatch displacement compute shader
	 */
	void DispatchDisplacement(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		FIntPoint Resolution,
		UTexture* DisplacementTexture,
		UTexture* SubtractTexture,
		FRDGBufferRef VertexBuffer,
		FRDGBufferRef NormalBuffer,
		FRDGBufferRef UVBuffer);

	/**
	 * Dispatch normal calculation compute shader
	 */
	void DispatchNormalCalculation(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		FIntPoint Resolution,
		UTexture* DisplacementTexture,
		UTexture* SubtractTexture,
		UTexture* NormalMapTexture,
		FRDGBufferRef VertexBuffer,
		FRDGBufferRef NormalBuffer,
		FRDGBufferRef UVBuffer);

	/**
	 * Dispatch tangent calculation compute shader
	 */
	void DispatchTangentCalculation(
		FRDGBuilder& GraphBuilder,
		FIntPoint Resolution,
		FRDGBufferRef VertexBuffer,
		FRDGBufferRef NormalBuffer,
		FRDGBufferRef UVBuffer,
		FRDGBufferRef& OutTangentBuffer);

	/**
	 * Dispatch index generation compute shader
	 */
	void DispatchIndexGeneration(
		FRDGBuilder& GraphBuilder,
		FIntPoint Resolution,
		FRDGBufferRef& OutIndexBuffer);

	/**
	 * Extract mesh data from GPU buffers to CPU
	 */
	void ExtractMeshData(
		FRDGBuilder& GraphBuilder,
		FIntPoint Resolution,
		FRDGBufferRef VertexBuffer,
		FRDGBufferRef NormalBuffer,
		FRDGBufferRef UVBuffer,
		FRDGBufferRef IndexBuffer,
		FGPUTessellatedMeshData& OutMeshData);

	/**
	 * Create RDG texture from UTexture (supports both UTexture2D and UTextureRenderTarget2D)
	 */
	FRDGTextureRef CreateRDGTextureFromUTexture(
		FRDGBuilder& GraphBuilder,
		UTexture* Texture,
		const TCHAR* Name);

	/**
	 * Get or create a default white texture
	 */
	FRDGTextureRef GetDefaultWhiteTexture(FRDGBuilder& GraphBuilder);

	/**
	 * Generate single patch with specific UV offset and size
	 */
	void GenerateSinglePatch(
		FRDGBuilder& GraphBuilder,
		const FGPUTessellationSettings& Settings,
		const FMatrix& LocalToWorld,
		const FVector2f& PatchUVOffset,
		const FVector2f& PatchUVSize,
		int32 TessellationLevel,
		UTexture* DisplacementTexture,
		UTexture* SubtractTexture,
		UTexture* NormalMapTexture,
		FGPUTessellationBuffers& OutPatchBuffers);

	/**
	 * Calculate patch information (bounds, centers, LOD levels)
	 */
	void CalculatePatchInfo(
		const FGPUTessellationSettings& Settings,
		const FMatrix& LocalToWorld,
		const FVector& CameraPosition,
		const FConvexVolume* ViewFrustum,
		int32 PatchCountX,
		int32 PatchCountY,
		TArray<FGPUTessellationPatchInfo>& OutPatchInfo) const;

	/**
	 * Determine tessellation level for a patch based on distance
	 */
	int32 CalculatePatchTessellationLevel(
		float DistanceToCamera,
		const FGPUTessellationSettings& Settings) const;

	/**
	 * Convert patch level enum to actual tessellation factor
	 */
	int32 ConvertPatchLevelToTessellation(EGPUTessellationPatchLevel Level) const;
};
